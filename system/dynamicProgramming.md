# 动态规划


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [动态规划](#动态规划)
	* [钢条切割](#钢条切割)
		* [自顶向下递归实现](#自顶向下递归实现)
		* [自顶向下(带备忘机制)](#自顶向下带备忘机制)
		* [自底向上版本](#自底向上版本)
		* [子问题](#子问题)

<!-- /code_chunk_output -->


动态规划与分治法相似，都是通过组合子问题的解来求解原问题。动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。在这种情况下，分治算法会作许多不必要的工作，它会反复地求解那些公共子子问题。而动态规划算法对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算，避免了这种不必要的计算工作。

动态规划通常用来求解最优化问题。

我们通常按照如下 4 个步骤来设计一个动态规划算法：
1. 刻画一个最优解的结构特征
2. 递归地定义最优解的值
3. 计算最优解的值，通常采用自底向上的方法
4. 利用计算出的信息构造一个最优解

步骤1～3 是动态规划的基础。如果我们仅仅需要一个最优解的值，而非解本身，可以忽略步骤4。如果哟确实需要做步骤 4 ，有时就需要在执行步骤 3 的过程中维护一些额外信息，以便用来构造一个最优解。

动态规划有两种等价的实现方法：
* 带备忘的自顶向下法
* 自底向上法
两种方法得到的算法具有相同的渐近运行时间，仅有的差异时在某些特殊情况下，自顶向下方法并未真正递归地考察所有可能的子问题。由于没有频繁的递归函数调用的开销，自底向上方法的时间复杂性函数通常具有更小的系数。

## 钢条切割

给定一段长度为 n 英寸的钢条和一个价格表 p ，求切割钢条方案，使得销售收益 r 最大。

| 长度 i    | 1 | 2 | 3 | 4 | 5  | 6  | 7  | 8  | 9  | 10 |
|-----------|---|---|---|---|----|----|----|----|----|----|
| 价格 p[i] | 1 | 5 | 8 | 9 | 10 | 17 | 17 | 20 | 24 | 30 |

最优切割方案：

![](../images/dynamicProgramming_201804051353_1.png)


### 自顶向下递归实现

![](../images/dynamicProgramming_201804051353_2.png)

### 自顶向下(带备忘机制)

![](../images/dynamicProgramming_201804051353_3.png)

![](../images/dynamicProgramming_201804051353_4.png)

### 自底向上版本

![](../images/dynamicProgramming_201804051353_5.png)

```c++
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

void cut(std::vector<int> &r, std::vector<int> p, int length) {
  int q = 0;
  for (int j = 1; j <= length; j++) {
    q = 0;
    for (int i = 1; i <= j; i++) {
      q = max(q, p[i] + r[j - i]);
    }
    r[j] = q;
  }
}

int main(int argc, char const *argv[]) {
  std::vector<int> p{0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
  std::vector<int> r(11, 0);
  cut(r, p, 10);

  for (auto i : r) {
    std::cout << i << '\n';
  }
  return 0;
}
```

Run it:

```sh
[breap@breap algorithm]$ gcp cutRod.cpp
0
1
5
8
10
13
17
18
22
25
30
```

### 子问题

当思考一个动态规划问题是，我们应该弄清楚所涉及的子问题以及子问题之间的依赖关系。

问题的子问题图准确地表达了这些信息。

n=4时钢条切割问题的子问题图：

![](../images/dynamicProgramming_201804051425_1.png)


注:
* 参考 《算法导论 3rd》 第 15 章节

[上一级](base.md)
[上一篇](UML.md)
[下一篇](graph.md)
