# 开发者测试


<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->
<!-- code_chunk_output -->

* [开发者测试](#开发者测试)
	* [开发者测试在软件质量中的角色](#开发者测试在软件质量中的角色)
	* [开发者测试的推荐方法](#开发者测试的推荐方法)
		* [测试先行还是测试后行](#测试先行还是测试后行)
		* [开发者测试的局限性](#开发者测试的局限性)

<!-- /code_chunk_output -->

测试是常见的改善质量的活动：
* `单元测试（Unit testing）`是将一个程序员或者一个开发团队所编写的，一个完整的类、子程序或者小程序，从完整的系统中隔离出来进行测试。
* `组件测试（Component testing）`是将一个类、包、小程序或者其他程序元素，从一个更加完整的系统中隔离出来进行测试，这些被测代码涉及到多个程序员或者多个团队。
* `集成测试（Integration testing）` 是对两个或更多的类、包、组件或者子系统进行的联合测试，这些组件由多个程序员或者开发团队所创建。这种测试通常在有了两个可以进行测试的类的时候就应该尽快开始，并且一直持续到整个系统开发完成。
* `回归测试（Regression testing）` 是指重复执行以前的测试用例，以便在原先通过了相同测试集合的软件中查找缺陷。
* `系统测试（System testing）` 是在最终的配置下（包括同其他软硬件系统的集成）运行整个软件。以便测试安全、性能、资源消耗、时序方面的问题，以及其他无法在低级集成上测试的问题。

测试通常分为两大类：黑盒测试 (black-box testing) 和 白盒 (white-box testing,或者 玻璃盒测试 glass-box testing)。
* 黑盒测试：指的是测试者无法了解测试对象内部工作机制的测试。
* 白盒测试：指的是测试者清楚待测对象内部工作机制的测试。
本章关注的是白盒测试，即由开发者完成的测试。

“测试” 和 “调试” 是不同的术语：
* 测试是一种检查错误的方法
* 调试意味着错误已经被发现，要做的是诊断错误并消灭造成这些错误的根本原因。

## 开发者测试在软件质量中的角色
对于任何软件质量规划来说，测试都是一个重要的组成部分，并且在许多情况下它是唯一的组成部分。这是非常不幸的，因为各种形式的协同开发实践都表现出比测试更高的错误检查率，而且发现一条测试的成本不到测试的二分之一。

测试对于绝大数开发人员来说都是一种煎熬：
* 测试的目标与开发活动背道而驰，测试的目标是找出错误。一个成功的测试应该弄跨软件，而其他开发活动的目标是避免程序错误和软件的崩溃。
* 测试永远不可能彻底证明程序中没有错误。
* 测试本身并不能改善软件的质量。测试的结果是软件质量的一个指示器，但是结果本身并不改善软件质量。
* 测试是要求你假设会在代码里面找到错误。

如下图所示，根据项目大小和复杂程度的不同，开发者测试应该占整个项目时间的 8% ~ 25%.

![](../images/developTest_201809011647_1.png)

理解测试基本概念可以更好地支持测试，也能提供测试的效率。

## 开发者测试的推荐方法
采用系统化的开发者测试方法，能最大限度提高你发现各种错误的能力，同时让你的花费也最少。请确保下面所有要点你都能做到：
* 对每一项相关的需求进行测试，以确保需求都已经被实现。在需求阶段就计划好这一部分的测试用例，或者至少尽早开始-最好在你开始编写代测试的单元之前。注意对需求里面常见的疏漏进行测试。安全级别、数据存储、安装过程以及系统可靠性等，这些都是测试的绝佳素材，并且常常在需求阶段被忽略。
* 对每一个相关的设计关注点进行测试，以确保设计已经被实现。
* 用基础测试（basis testing）来扩充针对需求和设计的详细测试用例。增加数据流测试（data-flow testing），然后补充其他所需的测试用例，以便对代码进行彻底的考验。至少你应该测试到每一行代码。
* 使用一个检查表，其中记录着你在项目迄今为止所犯的，以及在过去的项目中所犯的错误类型。

在设计产品的时候设计测试用例，这样可以帮助避免在需求和设计中产生错误，修正这些错误的代价往往比修正编码错误更昂贵。越早修复这些缺陷，成本就越低，因此，要尽可能地对测试进行规划并找出缺陷。

### 测试先行还是测试后行
通过下面的缺陷成本增长图，我们可以得到：首先写测试用例可以将从引入缺陷到发现并排除缺陷之间的时间缩减至最短。这正是首先写测试用例的诸多原因之一。

![](../images/developTest_201809011941_1.png)

* 在开始写代码先写测试用例，并不比之后在写要多花功夫，只是调整了一下测试用例编写活动的工作顺序而已。
* 假如你首先编写测试用例，那么你将可以更早发现缺陷，同时也更容易修正它们。
* 首先编写测试用例，将迫使你在开始写代码之前至少思考一下需求和设计，而这往往会催生更高质量的代码。
* 首先编写测试用例，能更早地把需求上的问题暴露出来，因为对于一个糟糕的需求来说，要写出测试用例是一件困难的事情。
* 如果你保存了最初的测试用例-这是你应该做的，那么先进行测试并非唯一选择，你仍然可以最后在进行测试。

总而言之，我认为测试先行的编程是过去十年中所形成的最有用的软件开发实践之一，同时也是一个非常好的通用方法。但这并不是一种测试万能药，正如接下来将要说明的那样，它同样受制于开发者测试本身的局限性。


### 开发者测试的局限性
应注意到开发者测试的下述局限性：
* 开发者测试倾向于 “干净测试”：开发人员往往去做一些检查代码能否工作的测试（干净测试，clean test）,而不是所用可能让代码失效的测试（肮脏测试，dirty test）。
* 开发者测试对覆盖率由过于乐观的估计
* 开发者测试往往会忽略一些更复杂的测试覆盖率类型


注： 读 《代码大全 2rd》 第 22 章 开发者测试，学习笔记

[上一级](base.md)
[上一篇](c++VSjava.md)
[下一篇](dynamicProgramming.md)
